(function (factory) {
    typeof define === 'function' && define.amd ? define(factory) :
    factory();
})((function () { 'use strict';

    /**
     * Copyright 2019 Google Inc. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *     http://www.apache.org/licenses/LICENSE-2.0
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    const proxyMarker = Symbol("Comlink.proxy");
    const createEndpoint = Symbol("Comlink.endpoint");
    const releaseProxy = Symbol("Comlink.releaseProxy");
    const throwMarker = Symbol("Comlink.thrown");
    const isObject = (val) => (typeof val === "object" && val !== null) || typeof val === "function";
    /**
     * Internal transfer handle to handle objects marked to proxy.
     */
    const proxyTransferHandler = {
        canHandle: (val) => isObject(val) && val[proxyMarker],
        serialize(obj) {
            const { port1, port2 } = new MessageChannel();
            expose(obj, port1);
            return [port2, [port2]];
        },
        deserialize(port) {
            port.start();
            return wrap(port);
        },
    };
    /**
     * Internal transfer handler to handle thrown exceptions.
     */
    const throwTransferHandler = {
        canHandle: (value) => isObject(value) && throwMarker in value,
        serialize({ value }) {
            let serialized;
            if (value instanceof Error) {
                serialized = {
                    isError: true,
                    value: {
                        message: value.message,
                        name: value.name,
                        stack: value.stack,
                    },
                };
            }
            else {
                serialized = { isError: false, value };
            }
            return [serialized, []];
        },
        deserialize(serialized) {
            if (serialized.isError) {
                throw Object.assign(new Error(serialized.value.message), serialized.value);
            }
            throw serialized.value;
        },
    };
    /**
     * Allows customizing the serialization of certain values.
     */
    const transferHandlers = new Map([
        ["proxy", proxyTransferHandler],
        ["throw", throwTransferHandler],
    ]);
    function expose(obj, ep = self) {
        ep.addEventListener("message", function callback(ev) {
            if (!ev || !ev.data) {
                return;
            }
            const { id, type, path } = Object.assign({ path: [] }, ev.data);
            const argumentList = (ev.data.argumentList || []).map(fromWireValue);
            let returnValue;
            try {
                const parent = path.slice(0, -1).reduce((obj, prop) => obj[prop], obj);
                const rawValue = path.reduce((obj, prop) => obj[prop], obj);
                switch (type) {
                    case "GET" /* GET */:
                        {
                            returnValue = rawValue;
                        }
                        break;
                    case "SET" /* SET */:
                        {
                            parent[path.slice(-1)[0]] = fromWireValue(ev.data.value);
                            returnValue = true;
                        }
                        break;
                    case "APPLY" /* APPLY */:
                        {
                            returnValue = rawValue.apply(parent, argumentList);
                        }
                        break;
                    case "CONSTRUCT" /* CONSTRUCT */:
                        {
                            const value = new rawValue(...argumentList);
                            returnValue = proxy(value);
                        }
                        break;
                    case "ENDPOINT" /* ENDPOINT */:
                        {
                            const { port1, port2 } = new MessageChannel();
                            expose(obj, port2);
                            returnValue = transfer(port1, [port1]);
                        }
                        break;
                    case "RELEASE" /* RELEASE */:
                        {
                            returnValue = undefined;
                        }
                        break;
                    default:
                        return;
                }
            }
            catch (value) {
                returnValue = { value, [throwMarker]: 0 };
            }
            Promise.resolve(returnValue)
                .catch((value) => {
                return { value, [throwMarker]: 0 };
            })
                .then((returnValue) => {
                const [wireValue, transferables] = toWireValue(returnValue);
                ep.postMessage(Object.assign(Object.assign({}, wireValue), { id }), transferables);
                if (type === "RELEASE" /* RELEASE */) {
                    // detach and deactive after sending release response above.
                    ep.removeEventListener("message", callback);
                    closeEndPoint(ep);
                }
            });
        });
        if (ep.start) {
            ep.start();
        }
    }
    function isMessagePort(endpoint) {
        return endpoint.constructor.name === "MessagePort";
    }
    function closeEndPoint(endpoint) {
        if (isMessagePort(endpoint))
            endpoint.close();
    }
    function wrap(ep, target) {
        return createProxy(ep, [], target);
    }
    function throwIfProxyReleased(isReleased) {
        if (isReleased) {
            throw new Error("Proxy has been released and is not useable");
        }
    }
    function createProxy(ep, path = [], target = function () { }) {
        let isProxyReleased = false;
        const proxy = new Proxy(target, {
            get(_target, prop) {
                throwIfProxyReleased(isProxyReleased);
                if (prop === releaseProxy) {
                    return () => {
                        return requestResponseMessage(ep, {
                            type: "RELEASE" /* RELEASE */,
                            path: path.map((p) => p.toString()),
                        }).then(() => {
                            closeEndPoint(ep);
                            isProxyReleased = true;
                        });
                    };
                }
                if (prop === "then") {
                    if (path.length === 0) {
                        return { then: () => proxy };
                    }
                    const r = requestResponseMessage(ep, {
                        type: "GET" /* GET */,
                        path: path.map((p) => p.toString()),
                    }).then(fromWireValue);
                    return r.then.bind(r);
                }
                return createProxy(ep, [...path, prop]);
            },
            set(_target, prop, rawValue) {
                throwIfProxyReleased(isProxyReleased);
                // FIXME: ES6 Proxy Handler `set` methods are supposed to return a
                // boolean. To show good will, we return true asynchronously ¯\_(ツ)_/¯
                const [value, transferables] = toWireValue(rawValue);
                return requestResponseMessage(ep, {
                    type: "SET" /* SET */,
                    path: [...path, prop].map((p) => p.toString()),
                    value,
                }, transferables).then(fromWireValue);
            },
            apply(_target, _thisArg, rawArgumentList) {
                throwIfProxyReleased(isProxyReleased);
                const last = path[path.length - 1];
                if (last === createEndpoint) {
                    return requestResponseMessage(ep, {
                        type: "ENDPOINT" /* ENDPOINT */,
                    }).then(fromWireValue);
                }
                // We just pretend that `bind()` didn’t happen.
                if (last === "bind") {
                    return createProxy(ep, path.slice(0, -1));
                }
                const [argumentList, transferables] = processArguments(rawArgumentList);
                return requestResponseMessage(ep, {
                    type: "APPLY" /* APPLY */,
                    path: path.map((p) => p.toString()),
                    argumentList,
                }, transferables).then(fromWireValue);
            },
            construct(_target, rawArgumentList) {
                throwIfProxyReleased(isProxyReleased);
                const [argumentList, transferables] = processArguments(rawArgumentList);
                return requestResponseMessage(ep, {
                    type: "CONSTRUCT" /* CONSTRUCT */,
                    path: path.map((p) => p.toString()),
                    argumentList,
                }, transferables).then(fromWireValue);
            },
        });
        return proxy;
    }
    function myFlat(arr) {
        return Array.prototype.concat.apply([], arr);
    }
    function processArguments(argumentList) {
        const processed = argumentList.map(toWireValue);
        return [processed.map((v) => v[0]), myFlat(processed.map((v) => v[1]))];
    }
    const transferCache = new WeakMap();
    function transfer(obj, transfers) {
        transferCache.set(obj, transfers);
        return obj;
    }
    function proxy(obj) {
        return Object.assign(obj, { [proxyMarker]: true });
    }
    function toWireValue(value) {
        for (const [name, handler] of transferHandlers) {
            if (handler.canHandle(value)) {
                const [serializedValue, transferables] = handler.serialize(value);
                return [
                    {
                        type: "HANDLER" /* HANDLER */,
                        name,
                        value: serializedValue,
                    },
                    transferables,
                ];
            }
        }
        return [
            {
                type: "RAW" /* RAW */,
                value,
            },
            transferCache.get(value) || [],
        ];
    }
    function fromWireValue(value) {
        switch (value.type) {
            case "HANDLER" /* HANDLER */:
                return transferHandlers.get(value.name).deserialize(value.value);
            case "RAW" /* RAW */:
                return value.value;
        }
    }
    function requestResponseMessage(ep, msg, transfers) {
        return new Promise((resolve) => {
            const id = generateUUID();
            ep.addEventListener("message", function l(ev) {
                if (!ev.data || !ev.data.id || ev.data.id !== id) {
                    return;
                }
                ep.removeEventListener("message", l);
                resolve(ev.data);
            });
            if (ep.start) {
                ep.start();
            }
            ep.postMessage(Object.assign({ id }, msg), transfers);
        });
    }
    function generateUUID() {
        return new Array(4)
            .fill(0)
            .map(() => Math.floor(Math.random() * Number.MAX_SAFE_INTEGER).toString(16))
            .join("-");
    }

    // Copyright (c) 2021 Milan Raj
    // SPDX-License-Identifier: MIT

    // Used in pre.js
    // eslint-disable-next-line no-unused-vars
    let exprtkWasmUrl;

    (() => {
        const ENVIRONMENT_IS_WEB = typeof window === 'object';
        const ENVIRONMENT_IS_WORKER = typeof importScripts === 'function';
        const ENVIRONMENT_IS_NODE = typeof process === 'object' && typeof process.versions === 'object' && typeof process.versions.node === 'string';

        if (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER) {
            exprtkWasmUrl = new URL('exprtkcore.wasm', (typeof document === 'undefined' && typeof location === 'undefined' ? new (require('u' + 'rl').URL)('file:' + __filename).href : typeof document === 'undefined' ? location.href : (document.currentScript && document.currentScript.src || new URL('exorbitant-worker.js', document.baseURI).href))).toString();
        } else if (ENVIRONMENT_IS_NODE) {
            exprtkWasmUrl = `${__dirname}/exprtkcore.wasm`;
        }
    })();

    var exprtkcore = (function() {
      var _scriptDir = (typeof document === 'undefined' && typeof location === 'undefined' ? new (require('u' + 'rl').URL)('file:' + __filename).href : typeof document === 'undefined' ? location.href : (document.currentScript && document.currentScript.src || new URL('exorbitant-worker.js', document.baseURI).href));
      
      return (
    function(exprtkcore) {
      exprtkcore = exprtkcore || {};

    var Module = typeof exprtkcore !== "undefined" ? exprtkcore : {};

    var objAssign = Object.assign;

    var readyPromiseResolve, readyPromiseReject;

    Module["ready"] = new Promise(function(resolve, reject) {
     readyPromiseResolve = resolve;
     readyPromiseReject = reject;
    });

    Module.exprtkcore.wasmUrl = exprtkWasmUrl;

    var moduleOverrides = objAssign({}, Module);

    var arguments_ = [];

    var thisProgram = "./this.program";

    var quit_ = function(status, toThrow) {
     throw toThrow;
    };

    var ENVIRONMENT_IS_WEB = typeof window === "object";

    var ENVIRONMENT_IS_WORKER = typeof importScripts === "function";

    var ENVIRONMENT_IS_NODE = typeof process === "object" && typeof process.versions === "object" && typeof process.versions.node === "string";

    var scriptDirectory = "";

    function locateFile(path) {
     if (Module["locateFile"]) {
      return Module["locateFile"](path, scriptDirectory);
     }
     return scriptDirectory + path;
    }

    var read_, readAsync, readBinary;

    function logExceptionOnExit(e) {
     if (e instanceof ExitStatus) return;
     var toLog = e;
     err("exiting due to exception: " + toLog);
    }

    var fs;

    var nodePath;

    var requireNodeFS;

    if (ENVIRONMENT_IS_NODE) {
     if (ENVIRONMENT_IS_WORKER) {
      scriptDirectory = require("path").dirname(scriptDirectory) + "/";
     } else {
      scriptDirectory = __dirname + "/";
     }
     requireNodeFS = function() {
      if (!fs) {
       fs = require("fs");
       nodePath = require("path");
      }
     };
     read_ = function shell_read(filename, binary) {
      requireNodeFS();
      filename = nodePath["normalize"](filename);
      return fs.readFileSync(filename, binary ? null : "utf8");
     };
     readBinary = function readBinary(filename) {
      var ret = read_(filename, true);
      if (!ret.buffer) {
       ret = new Uint8Array(ret);
      }
      return ret;
     };
     readAsync = function readAsync(filename, onload, onerror) {
      requireNodeFS();
      filename = nodePath["normalize"](filename);
      fs.readFile(filename, function(err, data) {
       if (err) onerror(err); else onload(data.buffer);
      });
     };
     if (process["argv"].length > 1) {
      thisProgram = process["argv"][1].replace(/\\/g, "/");
     }
     arguments_ = process["argv"].slice(2);
     process["on"]("uncaughtException", function(ex) {
      if (!(ex instanceof ExitStatus)) {
       throw ex;
      }
     });
     process["on"]("unhandledRejection", function(reason) {
      throw reason;
     });
     quit_ = function(status, toThrow) {
      if (keepRuntimeAlive()) {
       process["exitCode"] = status;
       throw toThrow;
      }
      logExceptionOnExit(toThrow);
      process["exit"](status);
     };
     Module["inspect"] = function() {
      return "[Emscripten Module object]";
     };
    } else if (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER) {
     if (ENVIRONMENT_IS_WORKER) {
      scriptDirectory = self.location.href;
     } else if (typeof document !== "undefined" && document.currentScript) {
      scriptDirectory = document.currentScript.src;
     }
     if (_scriptDir) {
      scriptDirectory = _scriptDir;
     }
     if (scriptDirectory.indexOf("blob:") !== 0) {
      scriptDirectory = scriptDirectory.substr(0, scriptDirectory.replace(/[?#].*/, "").lastIndexOf("/") + 1);
     } else {
      scriptDirectory = "";
     }
     {
      read_ = function(url) {
       var xhr = new XMLHttpRequest();
       xhr.open("GET", url, false);
       xhr.send(null);
       return xhr.responseText;
      };
      if (ENVIRONMENT_IS_WORKER) {
       readBinary = function(url) {
        var xhr = new XMLHttpRequest();
        xhr.open("GET", url, false);
        xhr.responseType = "arraybuffer";
        xhr.send(null);
        return new Uint8Array(xhr.response);
       };
      }
      readAsync = function(url, onload, onerror) {
       var xhr = new XMLHttpRequest();
       xhr.open("GET", url, true);
       xhr.responseType = "arraybuffer";
       xhr.onload = function() {
        if (xhr.status == 200 || xhr.status == 0 && xhr.response) {
         onload(xhr.response);
         return;
        }
        onerror();
       };
       xhr.onerror = onerror;
       xhr.send(null);
      };
     }
    } else ;

    var out = Module["print"] || console.log.bind(console);

    var err = Module["printErr"] || console.warn.bind(console);

    objAssign(Module, moduleOverrides);

    moduleOverrides = null;

    if (Module["arguments"]) arguments_ = Module["arguments"];

    if (Module["thisProgram"]) thisProgram = Module["thisProgram"];

    if (Module["quit"]) quit_ = Module["quit"];

    var wasmBinary;

    if (Module["wasmBinary"]) wasmBinary = Module["wasmBinary"];

    var noExitRuntime = Module["noExitRuntime"] || false;

    if (typeof WebAssembly !== "object") {
     abort("no native wasm support detected");
    }

    var wasmMemory;

    var ABORT = false;

    var EXITSTATUS;

    var UTF8Decoder = typeof TextDecoder !== "undefined" ? new TextDecoder("utf8") : undefined;

    function UTF8ArrayToString(heap, idx, maxBytesToRead) {
     var endIdx = idx + maxBytesToRead;
     var endPtr = idx;
     while (heap[endPtr] && !(endPtr >= endIdx)) ++endPtr;
     if (endPtr - idx > 16 && heap.subarray && UTF8Decoder) {
      return UTF8Decoder.decode(heap.subarray(idx, endPtr));
     } else {
      var str = "";
      while (idx < endPtr) {
       var u0 = heap[idx++];
       if (!(u0 & 128)) {
        str += String.fromCharCode(u0);
        continue;
       }
       var u1 = heap[idx++] & 63;
       if ((u0 & 224) == 192) {
        str += String.fromCharCode((u0 & 31) << 6 | u1);
        continue;
       }
       var u2 = heap[idx++] & 63;
       if ((u0 & 240) == 224) {
        u0 = (u0 & 15) << 12 | u1 << 6 | u2;
       } else {
        u0 = (u0 & 7) << 18 | u1 << 12 | u2 << 6 | heap[idx++] & 63;
       }
       if (u0 < 65536) {
        str += String.fromCharCode(u0);
       } else {
        var ch = u0 - 65536;
        str += String.fromCharCode(55296 | ch >> 10, 56320 | ch & 1023);
       }
      }
     }
     return str;
    }

    function UTF8ToString(ptr, maxBytesToRead) {
     return ptr ? UTF8ArrayToString(HEAPU8, ptr, maxBytesToRead) : "";
    }

    function stringToUTF8Array(str, heap, outIdx, maxBytesToWrite) {
     if (!(maxBytesToWrite > 0)) return 0;
     var startIdx = outIdx;
     var endIdx = outIdx + maxBytesToWrite - 1;
     for (var i = 0; i < str.length; ++i) {
      var u = str.charCodeAt(i);
      if (u >= 55296 && u <= 57343) {
       var u1 = str.charCodeAt(++i);
       u = 65536 + ((u & 1023) << 10) | u1 & 1023;
      }
      if (u <= 127) {
       if (outIdx >= endIdx) break;
       heap[outIdx++] = u;
      } else if (u <= 2047) {
       if (outIdx + 1 >= endIdx) break;
       heap[outIdx++] = 192 | u >> 6;
       heap[outIdx++] = 128 | u & 63;
      } else if (u <= 65535) {
       if (outIdx + 2 >= endIdx) break;
       heap[outIdx++] = 224 | u >> 12;
       heap[outIdx++] = 128 | u >> 6 & 63;
       heap[outIdx++] = 128 | u & 63;
      } else {
       if (outIdx + 3 >= endIdx) break;
       heap[outIdx++] = 240 | u >> 18;
       heap[outIdx++] = 128 | u >> 12 & 63;
       heap[outIdx++] = 128 | u >> 6 & 63;
       heap[outIdx++] = 128 | u & 63;
      }
     }
     heap[outIdx] = 0;
     return outIdx - startIdx;
    }

    function stringToUTF8(str, outPtr, maxBytesToWrite) {
     return stringToUTF8Array(str, HEAPU8, outPtr, maxBytesToWrite);
    }

    function writeAsciiToMemory(str, buffer, dontAddNull) {
     for (var i = 0; i < str.length; ++i) {
      HEAP8[buffer++ >> 0] = str.charCodeAt(i);
     }
     if (!dontAddNull) HEAP8[buffer >> 0] = 0;
    }

    var HEAP8, HEAPU8, HEAP32;

    function updateGlobalBufferAndViews(buf) {
     Module["HEAP8"] = HEAP8 = new Int8Array(buf);
     Module["HEAP16"] = new Int16Array(buf);
     Module["HEAP32"] = HEAP32 = new Int32Array(buf);
     Module["HEAPU8"] = HEAPU8 = new Uint8Array(buf);
     Module["HEAPU16"] = new Uint16Array(buf);
     Module["HEAPU32"] = new Uint32Array(buf);
     Module["HEAPF32"] = new Float32Array(buf);
     Module["HEAPF64"] = new Float64Array(buf);
    }

    Module["INITIAL_MEMORY"] || 16777216;

    var wasmTable;

    var __ATPRERUN__ = [];

    var __ATINIT__ = [];

    var __ATMAIN__ = [];

    var __ATEXIT__ = [];

    var __ATPOSTRUN__ = [];

    var runtimeKeepaliveCounter = 0;

    function keepRuntimeAlive() {
     return noExitRuntime || runtimeKeepaliveCounter > 0;
    }

    function preRun() {
     if (Module["preRun"]) {
      if (typeof Module["preRun"] == "function") Module["preRun"] = [ Module["preRun"] ];
      while (Module["preRun"].length) {
       addOnPreRun(Module["preRun"].shift());
      }
     }
     callRuntimeCallbacks(__ATPRERUN__);
    }

    function initRuntime() {
     callRuntimeCallbacks(__ATINIT__);
    }

    function preMain() {
     callRuntimeCallbacks(__ATMAIN__);
    }

    function exitRuntime() {
     callRuntimeCallbacks(__ATEXIT__);
     flush_NO_FILESYSTEM();
    }

    function postRun() {
     if (Module["postRun"]) {
      if (typeof Module["postRun"] == "function") Module["postRun"] = [ Module["postRun"] ];
      while (Module["postRun"].length) {
       addOnPostRun(Module["postRun"].shift());
      }
     }
     callRuntimeCallbacks(__ATPOSTRUN__);
    }

    function addOnPreRun(cb) {
     __ATPRERUN__.unshift(cb);
    }

    function addOnPostRun(cb) {
     __ATPOSTRUN__.unshift(cb);
    }

    var runDependencies = 0;

    var dependenciesFulfilled = null;

    function addRunDependency(id) {
     runDependencies++;
     if (Module["monitorRunDependencies"]) {
      Module["monitorRunDependencies"](runDependencies);
     }
    }

    function removeRunDependency(id) {
     runDependencies--;
     if (Module["monitorRunDependencies"]) {
      Module["monitorRunDependencies"](runDependencies);
     }
     if (runDependencies == 0) {
      if (dependenciesFulfilled) {
       var callback = dependenciesFulfilled;
       dependenciesFulfilled = null;
       callback();
      }
     }
    }

    Module["preloadedImages"] = {};

    Module["preloadedAudios"] = {};

    function abort(what) {
     {
      if (Module["onAbort"]) {
       Module["onAbort"](what);
      }
     }
     what = "Aborted(" + what + ")";
     err(what);
     ABORT = true;
     EXITSTATUS = 1;
     what += ". Build with -s ASSERTIONS=1 for more info.";
     var e = new WebAssembly.RuntimeError(what);
     readyPromiseReject(e);
     throw e;
    }

    var dataURIPrefix = "data:application/octet-stream;base64,";

    function isDataURI(filename) {
     return filename.startsWith(dataURIPrefix);
    }

    function isFileURI(filename) {
     return filename.startsWith("file://");
    }

    var wasmBinaryFile;

    if (Module["locateFile"]) {
     wasmBinaryFile = "exprtkcore.wasm";
     if (!isDataURI(wasmBinaryFile)) {
      wasmBinaryFile = locateFile(wasmBinaryFile);
     }
    } else {
     wasmBinaryFile = new URL("exprtkcore.wasm", (typeof document === 'undefined' && typeof location === 'undefined' ? new (require('u' + 'rl').URL)('file:' + __filename).href : typeof document === 'undefined' ? location.href : (document.currentScript && document.currentScript.src || new URL('exorbitant-worker.js', document.baseURI).href))).toString();
    }

    function getBinary(file) {
     try {
      if (file == wasmBinaryFile && wasmBinary) {
       return new Uint8Array(wasmBinary);
      }
      if (readBinary) {
       return readBinary(file);
      } else {
       throw "both async and sync fetching of the wasm failed";
      }
     } catch (err) {
      abort(err);
     }
    }

    function getBinaryPromise() {
     if (!wasmBinary && (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER)) {
      if (typeof fetch === "function" && !isFileURI(wasmBinaryFile)) {
       return fetch(wasmBinaryFile, {
        credentials: "same-origin"
       }).then(function(response) {
        if (!response["ok"]) {
         throw "failed to load wasm binary file at '" + wasmBinaryFile + "'";
        }
        return response["arrayBuffer"]();
       }).catch(function() {
        return getBinary(wasmBinaryFile);
       });
      } else {
       if (readAsync) {
        return new Promise(function(resolve, reject) {
         readAsync(wasmBinaryFile, function(response) {
          resolve(new Uint8Array(response));
         }, reject);
        });
       }
      }
     }
     return Promise.resolve().then(function() {
      return getBinary(wasmBinaryFile);
     });
    }

    function createWasm() {
     var info = {
      "env": asmLibraryArg,
      "wasi_snapshot_preview1": asmLibraryArg
     };
     function receiveInstance(instance, module) {
      var exports = instance.exports;
      Module["asm"] = exports;
      wasmMemory = Module["asm"]["memory"];
      updateGlobalBufferAndViews(wasmMemory.buffer);
      wasmTable = Module["asm"]["__indirect_function_table"];
      removeRunDependency();
     }
     addRunDependency();
     function receiveInstantiationResult(result) {
      receiveInstance(result["instance"]);
     }
     function instantiateArrayBuffer(receiver) {
      return getBinaryPromise().then(function(binary) {
       return WebAssembly.instantiate(binary, info);
      }).then(function(instance) {
       return instance;
      }).then(receiver, function(reason) {
       err("failed to asynchronously prepare wasm: " + reason);
       abort(reason);
      });
     }
     function instantiateAsync() {
      if (!wasmBinary && typeof WebAssembly.instantiateStreaming === "function" && !isDataURI(wasmBinaryFile) && !isFileURI(wasmBinaryFile) && typeof fetch === "function") {
       return fetch(wasmBinaryFile, {
        credentials: "same-origin"
       }).then(function(response) {
        var result = WebAssembly.instantiateStreaming(response, info);
        return result.then(receiveInstantiationResult, function(reason) {
         err("wasm streaming compile failed: " + reason);
         err("falling back to ArrayBuffer instantiation");
         return instantiateArrayBuffer(receiveInstantiationResult);
        });
       });
      } else {
       return instantiateArrayBuffer(receiveInstantiationResult);
      }
     }
     if (Module["instantiateWasm"]) {
      try {
       var exports = Module["instantiateWasm"](info, receiveInstance);
       return exports;
      } catch (e) {
       err("Module.instantiateWasm callback failed with error: " + e);
       return false;
      }
     }
     instantiateAsync().catch(readyPromiseReject);
     return {};
    }

    function callRuntimeCallbacks(callbacks) {
     while (callbacks.length > 0) {
      var callback = callbacks.shift();
      if (typeof callback == "function") {
       callback(Module);
       continue;
      }
      var func = callback.func;
      if (typeof func === "number") {
       if (callback.arg === undefined) {
        getWasmTableEntry(func)();
       } else {
        getWasmTableEntry(func)(callback.arg);
       }
      } else {
       func(callback.arg === undefined ? null : callback.arg);
      }
     }
    }

    var wasmTableMirror = [];

    function getWasmTableEntry(funcPtr) {
     var func = wasmTableMirror[funcPtr];
     if (!func) {
      if (funcPtr >= wasmTableMirror.length) wasmTableMirror.length = funcPtr + 1;
      wasmTableMirror[funcPtr] = func = wasmTable.get(funcPtr);
     }
     return func;
    }

    function handleException(e) {
     if (e instanceof ExitStatus || e == "unwind") {
      return EXITSTATUS;
     }
     quit_(1, e);
    }

    var SYSCALLS = {
     mappings: {},
     buffers: [ null, [], [] ],
     printChar: function(stream, curr) {
      var buffer = SYSCALLS.buffers[stream];
      if (curr === 0 || curr === 10) {
       (stream === 1 ? out : err)(UTF8ArrayToString(buffer, 0));
       buffer.length = 0;
      } else {
       buffer.push(curr);
      }
     },
     varargs: undefined,
     get: function() {
      SYSCALLS.varargs += 4;
      var ret = HEAP32[SYSCALLS.varargs - 4 >> 2];
      return ret;
     },
     getStr: function(ptr) {
      var ret = UTF8ToString(ptr);
      return ret;
     },
     get64: function(low, high) {
      return low;
     }
    };

    function _args_get(argv, argv_buf) {
     var bufSize = 0;
     mainArgs.forEach(function(arg, i) {
      var ptr = argv_buf + bufSize;
      HEAP32[argv + i * 4 >> 2] = ptr;
      writeAsciiToMemory(arg, ptr);
      bufSize += arg.length + 1;
     });
     return 0;
    }

    function _args_sizes_get(pargc, pargv_buf_size) {
     HEAP32[pargc >> 2] = mainArgs.length;
     var bufSize = 0;
     mainArgs.forEach(function(arg) {
      bufSize += arg.length + 1;
     });
     HEAP32[pargv_buf_size >> 2] = bufSize;
     return 0;
    }

    var ENV = {};

    function getExecutableName() {
     return thisProgram || "./this.program";
    }

    function getEnvStrings() {
     if (!getEnvStrings.strings) {
      var lang = (typeof navigator === "object" && navigator.languages && navigator.languages[0] || "C").replace("-", "_") + ".UTF-8";
      var env = {
       "USER": "web_user",
       "LOGNAME": "web_user",
       "PATH": "/",
       "PWD": "/",
       "HOME": "/home/web_user",
       "LANG": lang,
       "_": getExecutableName()
      };
      for (var x in ENV) {
       if (ENV[x] === undefined) delete env[x]; else env[x] = ENV[x];
      }
      var strings = [];
      for (var x in env) {
       strings.push(x + "=" + env[x]);
      }
      getEnvStrings.strings = strings;
     }
     return getEnvStrings.strings;
    }

    function _environ_get(__environ, environ_buf) {
     var bufSize = 0;
     getEnvStrings().forEach(function(string, i) {
      var ptr = environ_buf + bufSize;
      HEAP32[__environ + i * 4 >> 2] = ptr;
      writeAsciiToMemory(string, ptr);
      bufSize += string.length + 1;
     });
     return 0;
    }

    function _environ_sizes_get(penviron_count, penviron_buf_size) {
     var strings = getEnvStrings();
     HEAP32[penviron_count >> 2] = strings.length;
     var bufSize = 0;
     strings.forEach(function(string) {
      bufSize += string.length + 1;
     });
     HEAP32[penviron_buf_size >> 2] = bufSize;
     return 0;
    }

    function _fd_close(fd) {
     return 0;
    }

    function _fd_read(fd, iov, iovcnt, pnum) {
     var stream = SYSCALLS.getStreamFromFD(fd);
     var num = SYSCALLS.doReadv(stream, iov, iovcnt);
     HEAP32[pnum >> 2] = num;
     return 0;
    }

    function _fd_seek(fd, offset_low, offset_high, whence, newOffset) {}

    function flush_NO_FILESYSTEM() {
     if (typeof _fflush !== "undefined") _fflush(0);
     var buffers = SYSCALLS.buffers;
     if (buffers[1].length) SYSCALLS.printChar(1, 10);
     if (buffers[2].length) SYSCALLS.printChar(2, 10);
    }

    function _fd_write(fd, iov, iovcnt, pnum) {
     var num = 0;
     for (var i = 0; i < iovcnt; i++) {
      var ptr = HEAP32[iov >> 2];
      var len = HEAP32[iov + 4 >> 2];
      iov += 8;
      for (var j = 0; j < len; j++) {
       SYSCALLS.printChar(fd, HEAPU8[ptr + j]);
      }
      num += len;
     }
     HEAP32[pnum >> 2] = num;
     return 0;
    }

    function _proc_exit(code) {
     procExit(code);
    }

    var asmLibraryArg = {
     "args_get": _args_get,
     "args_sizes_get": _args_sizes_get,
     "environ_get": _environ_get,
     "environ_sizes_get": _environ_sizes_get,
     "fd_close": _fd_close,
     "fd_read": _fd_read,
     "fd_seek": _fd_seek,
     "fd_write": _fd_write,
     "proc_exit": _proc_exit
    };

    createWasm();

    Module["_SymbolTable_Create"] = function() {
     return (Module["_SymbolTable_Create"] = Module["asm"]["SymbolTable_Create"]).apply(null, arguments);
    };

    Module["_SymbolTable_Destroy"] = function() {
     return (Module["_SymbolTable_Destroy"] = Module["asm"]["SymbolTable_Destroy"]).apply(null, arguments);
    };

    Module["_SymbolTable_AddConstants"] = function() {
     return (Module["_SymbolTable_AddConstants"] = Module["asm"]["SymbolTable_AddConstants"]).apply(null, arguments);
    };

    Module["_PackageIO_Create"] = function() {
     return (Module["_PackageIO_Create"] = Module["asm"]["PackageIO_Create"]).apply(null, arguments);
    };

    Module["_PackageIO_Destroy"] = function() {
     return (Module["_PackageIO_Destroy"] = Module["asm"]["PackageIO_Destroy"]).apply(null, arguments);
    };

    Module["_SymbolTable_AddPackageIO"] = function() {
     return (Module["_SymbolTable_AddPackageIO"] = Module["asm"]["SymbolTable_AddPackageIO"]).apply(null, arguments);
    };

    Module["_PackageVecops_Create"] = function() {
     return (Module["_PackageVecops_Create"] = Module["asm"]["PackageVecops_Create"]).apply(null, arguments);
    };

    Module["_PackageVecops_Destroy"] = function() {
     return (Module["_PackageVecops_Destroy"] = Module["asm"]["PackageVecops_Destroy"]).apply(null, arguments);
    };

    Module["_SymbolTable_AddPackageVecops"] = function() {
     return (Module["_SymbolTable_AddPackageVecops"] = Module["asm"]["SymbolTable_AddPackageVecops"]).apply(null, arguments);
    };

    Module["_SymbolTable_AddVariable"] = function() {
     return (Module["_SymbolTable_AddVariable"] = Module["asm"]["SymbolTable_AddVariable"]).apply(null, arguments);
    };

    Module["_SymbolTable_AddVector"] = function() {
     return (Module["_SymbolTable_AddVector"] = Module["asm"]["SymbolTable_AddVector"]).apply(null, arguments);
    };

    Module["_Expression_Create"] = function() {
     return (Module["_Expression_Create"] = Module["asm"]["Expression_Create"]).apply(null, arguments);
    };

    Module["_Expression_Destroy"] = function() {
     return (Module["_Expression_Destroy"] = Module["asm"]["Expression_Destroy"]).apply(null, arguments);
    };

    Module["_Expression_RegisterSymbolTable"] = function() {
     return (Module["_Expression_RegisterSymbolTable"] = Module["asm"]["Expression_RegisterSymbolTable"]).apply(null, arguments);
    };

    Module["_Expression_Value"] = function() {
     return (Module["_Expression_Value"] = Module["asm"]["Expression_Value"]).apply(null, arguments);
    };

    Module["_Parser_Create"] = function() {
     return (Module["_Parser_Create"] = Module["asm"]["Parser_Create"]).apply(null, arguments);
    };

    Module["_Parser_Destroy"] = function() {
     return (Module["_Parser_Destroy"] = Module["asm"]["Parser_Destroy"]).apply(null, arguments);
    };

    Module["_Parser_Compile"] = function() {
     return (Module["_Parser_Compile"] = Module["asm"]["Parser_Compile"]).apply(null, arguments);
    };

    Module["_Parser_PrintError"] = function() {
     return (Module["_Parser_PrintError"] = Module["asm"]["Parser_PrintError"]).apply(null, arguments);
    };

    Module["_PackageArmadillo_Create"] = function() {
     return (Module["_PackageArmadillo_Create"] = Module["asm"]["PackageArmadillo_Create"]).apply(null, arguments);
    };

    Module["_PackageArmadillo_Destroy"] = function() {
     return (Module["_PackageArmadillo_Destroy"] = Module["asm"]["PackageArmadillo_Destroy"]).apply(null, arguments);
    };

    Module["_SymbolTable_AddPackageArmadillo"] = function() {
     return (Module["_SymbolTable_AddPackageArmadillo"] = Module["asm"]["SymbolTable_AddPackageArmadillo"]).apply(null, arguments);
    };

    Module["_PackageSigpack_Create"] = function() {
     return (Module["_PackageSigpack_Create"] = Module["asm"]["PackageSigpack_Create"]).apply(null, arguments);
    };

    Module["_PackageSigpack_Destroy"] = function() {
     return (Module["_PackageSigpack_Destroy"] = Module["asm"]["PackageSigpack_Destroy"]).apply(null, arguments);
    };

    Module["_SymbolTable_AddPackageSigpack"] = function() {
     return (Module["_SymbolTable_AddPackageSigpack"] = Module["asm"]["SymbolTable_AddPackageSigpack"]).apply(null, arguments);
    };

    Module["_free"] = function() {
     return (Module["_free"] = Module["asm"]["free"]).apply(null, arguments);
    };

    Module["__start"] = function() {
     return (Module["__start"] = Module["asm"]["_start"]).apply(null, arguments);
    };

    var stackSave = Module["stackSave"] = function() {
     return (stackSave = Module["stackSave"] = Module["asm"]["stackSave"]).apply(null, arguments);
    };

    var stackRestore = Module["stackRestore"] = function() {
     return (stackRestore = Module["stackRestore"] = Module["asm"]["stackRestore"]).apply(null, arguments);
    };

    var stackAlloc = Module["stackAlloc"] = function() {
     return (stackAlloc = Module["stackAlloc"] = Module["asm"]["stackAlloc"]).apply(null, arguments);
    };

    Module["_malloc"] = function() {
     return (Module["_malloc"] = Module["asm"]["malloc"]).apply(null, arguments);
    };

    Module["UTF8ArrayToString"] = UTF8ArrayToString;

    Module["stringToUTF8"] = stringToUTF8;

    Module["stackSave"] = stackSave;

    Module["stackRestore"] = stackRestore;

    Module["stackAlloc"] = stackAlloc;

    var calledRun;

    function ExitStatus(status) {
     this.name = "ExitStatus";
     this.message = "Program terminated with exit(" + status + ")";
     this.status = status;
    }

    var mainArgs = undefined;

    dependenciesFulfilled = function runCaller() {
     if (!calledRun) run();
     if (!calledRun) dependenciesFulfilled = runCaller;
    };

    function callMain(args) {
     var entryFunction = Module["__start"];
     mainArgs = [ thisProgram ].concat(args);
     try {
      entryFunction();
      var ret = 0;
      exit(ret, true);
      return ret;
     } catch (e) {
      return handleException(e);
     } finally {
     }
    }

    function run(args) {
     args = args || arguments_;
     if (runDependencies > 0) {
      return;
     }
     preRun();
     if (runDependencies > 0) {
      return;
     }
     function doRun() {
      if (calledRun) return;
      calledRun = true;
      Module["calledRun"] = true;
      if (ABORT) return;
      initRuntime();
      preMain();
      readyPromiseResolve(Module);
      if (Module["onRuntimeInitialized"]) Module["onRuntimeInitialized"]();
      if (shouldRunNow) callMain(args);
      postRun();
     }
     if (Module["setStatus"]) {
      Module["setStatus"]("Running...");
      setTimeout(function() {
       setTimeout(function() {
        Module["setStatus"]("");
       }, 1);
       doRun();
      }, 1);
     } else {
      doRun();
     }
    }

    Module["run"] = run;

    function exit(status, implicit) {
     EXITSTATUS = status;
     if (keepRuntimeAlive()) ; else {
      exitRuntime();
     }
     procExit(status);
    }

    function procExit(code) {
     EXITSTATUS = code;
     if (!keepRuntimeAlive()) {
      if (Module["onExit"]) Module["onExit"](code);
      ABORT = true;
     }
     quit_(code, new ExitStatus(code));
    }

    if (Module["preInit"]) {
     if (typeof Module["preInit"] == "function") Module["preInit"] = [ Module["preInit"] ];
     while (Module["preInit"].length > 0) {
      Module["preInit"].pop()();
     }
    }

    var shouldRunNow = true;

    if (Module["noInitialRun"]) shouldRunNow = false;

    run();

    Module.exprtkcore.flush = flush_NO_FILESYSTEM;


      return exprtkcore.ready
    }
    );
    })();

    // Copyright (c) 2021 Milan Raj

    // Make sure to use Module.stackSave() before calling
    const writeStringToStack = function (Module, str) {
        // Algorithm from emscripten ccall toC string
        // eslint-disable-next-line no-bitwise
        const strMaxStackLength = (str.length << 2) + 1;
        const strStackPointer = Module.stackAlloc(strMaxStackLength);
        Module.stringToUTF8(str, strStackPointer, strMaxStackLength);
        return strStackPointer;
    };

    class Variable {
        constructor (Module, symbolTableRef, name) {
            const variableRef = Module._malloc(8);
            if (variableRef === 0) {
                throw new Error(`Not enough memory to allocate variable ${name}.`);
            }
            const stack = Module.stackSave();
            const nameRef = writeStringToStack(Module, name);
            const result = Module._SymbolTable_AddVariable(symbolTableRef, nameRef, variableRef);
            Module.stackRestore(stack);
            Module.exprtkcore.flush();
            if (!result) {
                throw new Error(`Failed to create variable with name ${name}`);
            }
            this._Module = Module;
            this._variableRef = variableRef;
        }

        destroy () {
            this._Module._free(this._variableRef);
            this._variableRef = undefined;
            this._Module = undefined;
        }

        set value (number) {
            this._Module.HEAPF64[this._variableRef / 8] = number;
        }

        get value () {
            return this._Module.HEAPF64[this._variableRef / 8];
        }
    }

    class Vector {
        constructor (Module, symbolTableRef, name, size) {
            const vectorRef = Module._malloc(size * 8);
            if (vectorRef === 0) {
                throw new Error(`Not enough memory to allocate vector ${name} with size ${size}.`);
            }
            const stack = Module.stackSave();
            const nameRef = writeStringToStack(Module, name);
            const result = Module._SymbolTable_AddVector(symbolTableRef, nameRef, vectorRef, size);
            Module.stackRestore(stack);
            Module.exprtkcore.flush();
            if (!result) {
                throw new Error(`Failed to create vector with name ${name}`);
            }
            this._Module = Module;
            this._vectorRef = vectorRef;
            this._size = size;
        }

        destroy () {
            this._Module._free(this._vectorRef);
            this._vectorRef = undefined;
            this._size = undefined;
            this._Module = undefined;
        }

        // Only valid until before another function used. DO NO SAVE REFERENCE.
        // Memory growth due to function execution will invalidate buffer.
        createBufferView () {
            return new Float64Array(this._Module.HEAPF64.buffer, this._vectorRef, this._size);
        }

        assign (arrayLike) {
            for (let i = this._vectorRef / 8; i < this._size; i++) {
                this._Module.HEAPF64[i] = arrayLike[i];
            }
        }
    }

    class SymbolTable {
        constructor (Module) {
            this._Module = Module;
            this._symbolTableRef = this._Module._SymbolTable_Create();
            this._packageIORef = undefined;
            this._packageVecopsRef = undefined;
            this._packageArmadilloRef = undefined;
            this._packageSigpackRef = undefined;
            this._Module.exprtkcore.flush();
        }

        destroy () {
            this._Module._SymbolTable_Destroy(this._symbolTableRef);
            this._symbolTableRef = undefined;
            if (this._packageIORef) {
                this._Module._PackageIO_Destroy(this._packageIORef);
                this._packageIORef = undefined;
            }
            if (this._packageVecopsRef) {
                this._Module._PackageVecops_Destroy(this._packageVecopsRef);
                this._packageVecopsRef = undefined;
            }
            if (this._packageArmadilloRef) {
                this._Module._PackageArmadillo_Destroy(this._packageArmadilloRef);
                this._packageArmadilloRef = undefined;
            }
            if (this._packageSigpackRef) {
                this._Module._PackageSigpack_Destroy(this._packageSigpackRef);
                this._packageSigpackRef = undefined;
            }
            this._Module.exprtkcore.flush();
            this._Module = undefined;
        }

        addConstants () {
            const result = this._Module._SymbolTable_AddConstants(this._symbolTableRef);
            this._Module.exprtkcore.flush();
            if (!result) {
                throw new Error('Failed to add constants to symbol table');
            }
        }

        addPackageIO () {
            if (this._packageIORef) {
                throw new Error('Package IO already defined in symbol table');
            }
            this._packageIORef = this._Module._PackageIO_Create();
            const result = this._Module._SymbolTable_AddPackageIO(this._symbolTableRef, this._packageIORef);
            this._Module.exprtkcore.flush();
            if (!result) {
                this._Module._PackageIO_Destroy(this._packageIORef);
                this._packageIORef = undefined;
                throw new Error('Failed to add package IO to symbol table');
            }
        }

        addPackageVecops () {
            if (this._packageVecopsRef) {
                throw new Error('Package Vecops already defined in symbol table');
            }
            this._packageVecopsRef = this._Module._PackageVecops_Create();
            const result = this._Module._SymbolTable_AddPackageVecops(this._symbolTableRef, this._packageVecopsRef);
            this._Module.exprtkcore.flush();
            if (!result) {
                this._Module._PackageVecops_Destroy(this._packageVecopsRef);
                this._packageVecopsRef = undefined;
                throw new Error('Failed to add package Vecops to symbol table');
            }
        }

        addPackageArmadillo () {
            if (this._packageArmadilloRef) {
                throw new Error('Package Armadillo already defined in symbol table');
            }
            this._packageArmadilloRef = this._Module._PackageArmadillo_Create();
            const result = this._Module._SymbolTable_AddPackageArmadillo(this._symbolTableRef, this._packageArmadilloRef);
            this._Module.exprtkcore.flush();
            if (!result) {
                this._Module._PackageAramadillo_Destroy(this._packageArmadilloRef);
                this._packageArmadilloRef = undefined;
                throw new Error('Failed to add package Armadillo to symbol table');
            }
        }

        addPackageSigpack () {
            if (this._packageSigpackRef) {
                throw new Error('Package Sigpack already defined in symbol table');
            }
            this._packageSigpackRef = this._Module._PackageSigpack_Create();
            const result = this._Module._SymbolTable_AddPackageSigpack(this._symbolTableRef, this._packageSigpackRef);
            this._Module.exprtkcore.flush();
            if (!result) {
                this._Module._PackageSigpack_Destroy(this._packageSigpackRef);
                this._packageSigpackRef = undefined;
                throw new Error('Failed to add package Sigpack to symbol table');
            }
        }

        createVariable (name) {
            return new Variable(this._Module, this._symbolTableRef, name);
        }

        createVector (name, size) {
            return new Vector(this._Module, this._symbolTableRef, name, size);
        }
    }

    class Expression {
        constructor (Module) {
            this._Module = Module;
            this._expressionRef = this._Module._Expression_Create();
            this._Module.exprtkcore.flush();
        }

        destroy () {
            this._Module._Expression_Destroy(this._expressionRef);
            this._Module.exprtkcore.flush();
            this._expressionRef = undefined;
            this._Module = undefined;
        }

        registerSymbolTable (symbolTable) {
            this._Module._Expression_RegisterSymbolTable(this._expressionRef, symbolTable._symbolTableRef);
            this._Module.exprtkcore.flush();
        }

        value () {
            const ret = this._Module._Expression_Value(this._expressionRef);
            this._Module.exprtkcore.flush();
            return ret;
        }
    }

    class Parser {
        constructor (Module) {
            this._Module = Module;
            this._parserRef = this._Module._Parser_Create();
            this._Module.exprtkcore.flush();
        }

        destroy () {
            this._Module._Parser_Destroy(this._parserRef);
            this._Module.exprtkcore.flush();
            this._parserRef = undefined;
            this._Module = undefined;
        }

        compile (str, expression) {
            const stack = this._Module.stackSave();
            const strRef = writeStringToStack(this._Module, str);
            const result = this._Module._Parser_Compile(this._parserRef, strRef, expression._expressionRef);
            this._Module.stackRestore(stack);
            this._Module.exprtkcore.flush();
            if (!result) {
                // TODO instead of printing should pass error in exception
                this._Module._Parser_PrintError(this._parserRef);
                this._Module.exprtkcore.flush();
                throw new Error(`Failed to compile expression: ${str}`);
            }
        }
    }

    class Exprtk {
        constructor (Module) {
            this._Module = Module;
        }

        destroy () {
            this._Module = undefined;
        }

        createSymbolTable () {
            return new SymbolTable(this._Module);
        }

        createExpression () {
            return new Expression(this._Module);
        }

        createParser () {
            return new Parser(this._Module);
        }
    }

    const createModule = function () {
        const Module = {};
        Module.arguments = ['--exit'];
        Module.exprtkcore = {
            ENVIRONMENT_IS_WEB: typeof window === 'object',
            ENVIRONMENT_IS_WORKER: typeof importScripts === 'function',
            ENVIRONMENT_IS_NODE: typeof process === 'object' && typeof process.versions === 'object' && typeof process.versions.node === 'string',
            wasmUrl: '',
            flush: undefined
        };

        Module.locateFile = (path, prefix) => {
            if (path.endsWith('.wasm')) {
                return Module.exprtkcore.wasmUrl;
            }
            return prefix + path;
        };

        if (Module.exprtkcore.ENVIRONMENT_IS_NODE) {
            Module.quit = (_status, toThrow) => {
                throw toThrow;
            };
        }
        return Module;
    };

    const createExprtk = async function () {
        const Module = await exprtkcore(createModule());
        const ret = new Exprtk(Module);
        Module.exprtkcore.flush();
        return ret;
    };

    var configuration$1 = {exports: {}};

    configuration$1.exports = validate20;
    configuration$1.exports.default = validate20;

    function validate20(data, {instancePath="", parentData, parentDataProperty, rootData=data}={}){
    let vErrors = null;
    let errors = 0;
    const _errs0 = errors;
    if(errors === _errs0){
    if(data && typeof data == "object" && !Array.isArray(data)){
    let missing0;
    if((data.expression === undefined) && (missing0 = "expression")){
    validate20.errors = [{instancePath,schemaPath:"#/definitions/configuration/required",keyword:"required",params:{missingProperty: missing0},message:"must have required property '"+missing0+"'"}];
    return false;
    }
    else {
    if(data.expression !== undefined){
    const _errs2 = errors;
    if(typeof data.expression !== "string"){
    validate20.errors = [{instancePath:instancePath+"/expression",schemaPath:"#/definitions/configuration/properties/expression/type",keyword:"type",params:{type: "string"},message:"must be string"}];
    return false;
    }
    var valid1 = _errs2 === errors;
    }
    else {
    var valid1 = true;
    }
    if(valid1){
    if(data.symbolTable !== undefined){
    let data1 = data.symbolTable;
    const _errs4 = errors;
    if(errors === _errs4){
    if(data1 && typeof data1 == "object" && !Array.isArray(data1)){
    if(data1.variables !== undefined){
    let data2 = data1.variables;
    const _errs6 = errors;
    if(errors === _errs6){
    if(Array.isArray(data2)){
    var valid3 = true;
    const len0 = data2.length;
    for(let i0=0; i0<len0; i0++){
    let data3 = data2[i0];
    const _errs8 = errors;
    if(errors === _errs8){
    if(data3 && typeof data3 == "object" && !Array.isArray(data3)){
    let missing1;
    if((data3.name === undefined) && (missing1 = "name")){
    validate20.errors = [{instancePath:instancePath+"/symbolTable/variables/" + i0,schemaPath:"#/definitions/configuration/properties/symbolTable/properties/variables/items/required",keyword:"required",params:{missingProperty: missing1},message:"must have required property '"+missing1+"'"}];
    return false;
    }
    else {
    if(data3.name !== undefined){
    const _errs10 = errors;
    if(typeof data3.name !== "string"){
    validate20.errors = [{instancePath:instancePath+"/symbolTable/variables/" + i0+"/name",schemaPath:"#/definitions/configuration/properties/symbolTable/properties/variables/items/properties/name/type",keyword:"type",params:{type: "string"},message:"must be string"}];
    return false;
    }
    var valid4 = _errs10 === errors;
    }
    else {
    var valid4 = true;
    }
    if(valid4){
    if(data3.value !== undefined){
    let data5 = data3.value;
    const _errs12 = errors;
    if(!((typeof data5 == "number") && (isFinite(data5)))){
    validate20.errors = [{instancePath:instancePath+"/symbolTable/variables/" + i0+"/value",schemaPath:"#/definitions/configuration/properties/symbolTable/properties/variables/items/properties/value/type",keyword:"type",params:{type: "number"},message:"must be number"}];
    return false;
    }
    var valid4 = _errs12 === errors;
    }
    else {
    var valid4 = true;
    }
    }
    }
    }
    else {
    validate20.errors = [{instancePath:instancePath+"/symbolTable/variables/" + i0,schemaPath:"#/definitions/configuration/properties/symbolTable/properties/variables/items/type",keyword:"type",params:{type: "object"},message:"must be object"}];
    return false;
    }
    }
    var valid3 = _errs8 === errors;
    if(!valid3){
    break;
    }
    }
    }
    else {
    validate20.errors = [{instancePath:instancePath+"/symbolTable/variables",schemaPath:"#/definitions/configuration/properties/symbolTable/properties/variables/type",keyword:"type",params:{type: "array"},message:"must be array"}];
    return false;
    }
    }
    var valid2 = _errs6 === errors;
    }
    else {
    var valid2 = true;
    }
    if(valid2){
    if(data1.vectors !== undefined){
    let data6 = data1.vectors;
    const _errs14 = errors;
    if(errors === _errs14){
    if(Array.isArray(data6)){
    var valid5 = true;
    const len1 = data6.length;
    for(let i1=0; i1<len1; i1++){
    let data7 = data6[i1];
    const _errs16 = errors;
    if(errors === _errs16){
    if(data7 && typeof data7 == "object" && !Array.isArray(data7)){
    let missing2;
    if(((data7.name === undefined) && (missing2 = "name")) || ((data7.size === undefined) && (missing2 = "size"))){
    validate20.errors = [{instancePath:instancePath+"/symbolTable/vectors/" + i1,schemaPath:"#/definitions/configuration/properties/symbolTable/properties/vectors/items/required",keyword:"required",params:{missingProperty: missing2},message:"must have required property '"+missing2+"'"}];
    return false;
    }
    else {
    if(data7.name !== undefined){
    const _errs18 = errors;
    if(typeof data7.name !== "string"){
    validate20.errors = [{instancePath:instancePath+"/symbolTable/vectors/" + i1+"/name",schemaPath:"#/definitions/configuration/properties/symbolTable/properties/vectors/items/properties/name/type",keyword:"type",params:{type: "string"},message:"must be string"}];
    return false;
    }
    var valid6 = _errs18 === errors;
    }
    else {
    var valid6 = true;
    }
    if(valid6){
    if(data7.size !== undefined){
    let data9 = data7.size;
    const _errs20 = errors;
    if(!((typeof data9 == "number") && (isFinite(data9)))){
    validate20.errors = [{instancePath:instancePath+"/symbolTable/vectors/" + i1+"/size",schemaPath:"#/definitions/configuration/properties/symbolTable/properties/vectors/items/properties/size/type",keyword:"type",params:{type: "number"},message:"must be number"}];
    return false;
    }
    var valid6 = _errs20 === errors;
    }
    else {
    var valid6 = true;
    }
    if(valid6){
    if(data7.value !== undefined){
    let data10 = data7.value;
    const _errs22 = errors;
    const _errs23 = errors;
    let valid7 = false;
    const _errs24 = errors;
    if(errors === _errs24){
    if(data10 && typeof data10 == "object" && !Array.isArray(data10)){
    let missing3;
    if((data10.length === undefined) && (missing3 = "length")){
    const err0 = {instancePath:instancePath+"/symbolTable/vectors/" + i1+"/value",schemaPath:"#/definitions/configuration/properties/symbolTable/properties/vectors/items/properties/value/anyOf/0/required",keyword:"required",params:{missingProperty: missing3},message:"must have required property '"+missing3+"'"};
    if(vErrors === null){
    vErrors = [err0];
    }
    else {
    vErrors.push(err0);
    }
    errors++;
    }
    else {
    if(data10.length !== undefined){
    let data11 = data10.length;
    if(!((typeof data11 == "number") && (isFinite(data11)))){
    const err1 = {instancePath:instancePath+"/symbolTable/vectors/" + i1+"/value/length",schemaPath:"#/definitions/configuration/properties/symbolTable/properties/vectors/items/properties/value/anyOf/0/properties/length/type",keyword:"type",params:{type: "number"},message:"must be number"};
    if(vErrors === null){
    vErrors = [err1];
    }
    else {
    vErrors.push(err1);
    }
    errors++;
    }
    }
    }
    }
    else {
    const err2 = {instancePath:instancePath+"/symbolTable/vectors/" + i1+"/value",schemaPath:"#/definitions/configuration/properties/symbolTable/properties/vectors/items/properties/value/anyOf/0/type",keyword:"type",params:{type: "object"},message:"must be object"};
    if(vErrors === null){
    vErrors = [err2];
    }
    else {
    vErrors.push(err2);
    }
    errors++;
    }
    }
    var _valid0 = _errs24 === errors;
    valid7 = valid7 || _valid0;
    if(!valid7){
    const _errs28 = errors;
    if(errors === _errs28){
    if(!(Array.isArray(data10))){
    const err3 = {instancePath:instancePath+"/symbolTable/vectors/" + i1+"/value",schemaPath:"#/definitions/configuration/properties/symbolTable/properties/vectors/items/properties/value/anyOf/1/type",keyword:"type",params:{type: "array"},message:"must be array"};
    if(vErrors === null){
    vErrors = [err3];
    }
    else {
    vErrors.push(err3);
    }
    errors++;
    }
    }
    var _valid0 = _errs28 === errors;
    valid7 = valid7 || _valid0;
    }
    if(!valid7){
    const err4 = {instancePath:instancePath+"/symbolTable/vectors/" + i1+"/value",schemaPath:"#/definitions/configuration/properties/symbolTable/properties/vectors/items/properties/value/anyOf",keyword:"anyOf",params:{},message:"must match a schema in anyOf"};
    if(vErrors === null){
    vErrors = [err4];
    }
    else {
    vErrors.push(err4);
    }
    errors++;
    validate20.errors = vErrors;
    return false;
    }
    else {
    errors = _errs23;
    if(vErrors !== null){
    if(_errs23){
    vErrors.length = _errs23;
    }
    else {
    vErrors = null;
    }
    }
    }
    var valid6 = _errs22 === errors;
    }
    else {
    var valid6 = true;
    }
    }
    }
    }
    }
    else {
    validate20.errors = [{instancePath:instancePath+"/symbolTable/vectors/" + i1,schemaPath:"#/definitions/configuration/properties/symbolTable/properties/vectors/items/type",keyword:"type",params:{type: "object"},message:"must be object"}];
    return false;
    }
    }
    var valid5 = _errs16 === errors;
    if(!valid5){
    break;
    }
    }
    }
    else {
    validate20.errors = [{instancePath:instancePath+"/symbolTable/vectors",schemaPath:"#/definitions/configuration/properties/symbolTable/properties/vectors/type",keyword:"type",params:{type: "array"},message:"must be array"}];
    return false;
    }
    }
    var valid2 = _errs14 === errors;
    }
    else {
    var valid2 = true;
    }
    }
    }
    else {
    validate20.errors = [{instancePath:instancePath+"/symbolTable",schemaPath:"#/definitions/configuration/properties/symbolTable/type",keyword:"type",params:{type: "object"},message:"must be object"}];
    return false;
    }
    }
    var valid1 = _errs4 === errors;
    }
    else {
    var valid1 = true;
    }
    }
    }
    }
    else {
    validate20.errors = [{instancePath,schemaPath:"#/definitions/configuration/type",keyword:"type",params:{type: "object"},message:"must be object"}];
    return false;
    }
    }
    validate20.errors = vErrors;
    return errors === 0;
    }

    var configuration = configuration$1.exports;

    const validateConfiguration = function (configuration$1) {
        if (!configuration(configuration$1)) {
            throw new Error('Invalid configuration');
        }
    };

    class SymbolCache {
        constructor (symbolTable, symbolTableConfig) {
            this._variableMap = new Map();
            this._vectorMap = new Map();

            const isDefined = value => value !== undefined;
            if (isDefined(symbolTableConfig)) {
                if (isDefined(symbolTableConfig.variables)) {
                    for (const variableConfig of symbolTableConfig.variables) {
                        const variable = symbolTable.createVariable(variableConfig.name);
                        this._variableMap.set(variableConfig.name, variable);

                        if (isDefined(variableConfig.value)) {
                            variable.value = variableConfig.value;
                        }
                    }
                }
                if (isDefined(symbolTableConfig.vectors)) {
                    for (const vectorConfig of symbolTableConfig.vectors) {
                        const vector = symbolTable.createVector(vectorConfig.name, vectorConfig.size);
                        this._vectorMap.set(vectorConfig.name, vector);

                        if (isDefined(vectorConfig.value)) {
                            vector.assign(vectorConfig.value);
                        }
                    }
                }
            }
        }

        destroy () {
            for (const [, variable] of this._variableMap) {
                variable.destroy();
            }
            this._variableMap = undefined;
            for (const [, vector] of this._vectorMap) {
                vector.destroy();
            }
            this._vectorMap = undefined;
        }

        getVariable (name) {
            const variable = this._variableMap.get(name);
            if (!variable) {
                throw new Error(`Symbol with following name is not a valid variable: ${name}`);
            }
            return variable;
        }

        getVector (name) {
            const vector = this._vectorMap.get(name);
            if (!vector) {
                throw new Error(`Symbol with following name is not a valid vector: ${name}`);
            }
            return vector;
        }
    }

    // NOTE: All parameters return values should be structured cloneable to support Comlink
    class Exorbitant {
        constructor (exprtk, configuration) {
            validateConfiguration(configuration);

            this._symbolTable = exprtk.createSymbolTable();
            this._symbolTable.addConstants();
            this._symbolTable.addPackageIO();
            this._symbolTable.addPackageVecops();
            this._symbolTable.addPackageArmadillo();
            this._symbolTable.addPackageSigpack();

            this._symbolCache = new SymbolCache(this._symbolTable, configuration.symbolTable);

            this._expression = exprtk.createExpression();
            this._expression.registerSymbolTable(this._symbolTable);

            this._parser = exprtk.createParser();
            this._parser.compile(configuration.expression, this._expression);
        }

        destroy () {
            this._symbolTable.destroy();
            this._symbolTable = undefined;
            this._symbolCache.destroy();
            this._symbolCache = undefined;
            this._expression.destroy();
            this._expression = undefined;
            this._parser.destroy();
            this._parser = undefined;
        }

        getVariable (name) {
            const variable = this._symbolCache.getVariable(name);
            return variable.value;
        }

        setVariable (name, value) {
            const variable = this._symbolCache.getVariable(name);
            variable.value = value;
        }

        getVector (name) {
            const vector = this._symbolCache.getVector(name);
            const vectorBufferView = vector.createBufferView();
            const vectorCopy = new Float64Array(vectorBufferView);
            return vectorCopy;
        }

        setVector (name, value) {
            const vector = this._symbolCache.getVector(name);
            vector.assign(value);
        }

        value () {
            return this._expression.value();
        }
    }

    class ExorbitantRuntime {
        constructor () {
            this._exprtk = undefined;
        }

        destroy () {
            if (this._exprtk) {
                this._exprtk.destroy();
                this._exprtk = undefined;
            }
        }

        async createExorbitant (configuration) {
            if (this._exprtk === undefined) {
                this._exprtk = await createExprtk();
            }
            return new Exorbitant(this._exprtk, configuration);
        }
    }

    const createExorbitantRuntime = function () {
        return new ExorbitantRuntime();
    };

    class ExorbitantRuntimeWorker {
        constructor () {
            this._exorbitantRuntime = undefined;
        }

        destroy () {
            if (this._exorbitantRuntime) {
                this._exorbitantRuntime.destroy();
                this._exorbitantRuntime = undefined;
            }
        }

        async createExorbitant (configuration) {
            if (this._exorbitantRuntime === undefined) {
                this._exorbitantRuntime = createExorbitantRuntime();
            }
            const exorbitant = await this._exorbitantRuntime.createExorbitant(configuration);
            return proxy(exorbitant);
        }
    }

    const createExorbitantRuntimeWorker = function () {
        const exorbitantRuntimeWorker = new ExorbitantRuntimeWorker();
        return proxy(exorbitantRuntimeWorker);
    };

    expose(createExorbitantRuntimeWorker);

}));
